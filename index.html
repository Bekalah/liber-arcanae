<!doctype html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <title>Cosmic Helix Renderer (ND-safe, Offline)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <meta name="color-scheme" content="light dark">
  <style>
    /* ND-safe: gentle contrast, no motion, ample breathing room */
    :root {
      --bg:#0b0b12;
      --ink:#e8e8f0;
      --muted:#a6a6c1;
      --outline:#1d1d2a;
    }
    *,*::before,*::after { box-sizing:border-box; }
    html,body { margin:0; padding:0; background:var(--bg); color:var(--ink); font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
    header { padding:16px; border-bottom:1px solid var(--outline); }
    .title { margin:0 0 4px; font-size:18px; font-weight:600; }
    .status { font-size:12px; color:var(--muted); }
    main { padding:16px; display:flex; flex-direction:column; align-items:center; gap:16px; }
    #stage { display:block; width:1440px; height:900px; max-width:100%; box-shadow:0 0 0 1px var(--outline); background:var(--bg); }
    .note { max-width:920px; color:var(--muted); margin:0 auto; text-align:center; }
    @media (max-width:1500px) {
      #stage { width:100%; height:auto; }
    }
  </style>
</head>
<body>
  <header>
    <h1 class="title">Cosmic Helix Renderer — layered sacred geometry (offline)</h1>
    <p class="status" id="status" role="status" aria-live="polite">Loading palette…</p>
  </header>
  <main>
    <canvas id="stage" width="1440" height="900" role="img" aria-label="Vesica grid, Tree-of-Life, Fibonacci curve, and helix lattice"></canvas>
    <p class="note">This static, offline canvas honors vesica piscis harmonics, Tree-of-Life scaffolding, Fibonacci unfolding, and a calm double-helix lattice. No animation, no network calls, just pure layered geometry.</p>
  </main>
  <script type="module">
    import { renderHelix } from "./js/helix-renderer.mjs";

    const statusEl = document.getElementById("status");
    const canvas = document.getElementById("stage");
    const ctx = canvas.getContext("2d");

    async function loadPalette(path) {
      try {
        const res = await fetch(path, { cache: "no-store" });
        if (!res.ok) throw new Error(String(res.status));
        return await res.json();
      } catch (error) {
        return null;
      }
    }

    const defaults = {
      bg: "#0b0b12",
      ink: "#e8e8f0",
      layers: ["#b1c7ff", "#89f7fe", "#a0ffa1", "#ffd27f", "#f5a3ff", "#d0d0e6"]
    };

    const palette = await loadPalette("./data/palette.json");
    const active = palette || defaults;

    if (palette) {
      statusEl.textContent = "Palette loaded.";
    } else {
      statusEl.textContent = "Palette missing; using safe fallback.";
    }

    // Align CSS custom properties so the full page reflects the palette
    const root = document.documentElement.style;
    root.setProperty("--bg", active.bg);
    root.setProperty("--ink", active.ink);

    const NUM = {
      THREE:3,
      SEVEN:7,
      NINE:9,
      ELEVEN:11,
      TWENTYTWO:22,
      THIRTYTHREE:33,
      NINETYNINE:99,
      ONEFORTYFOUR:144
    };

    // ND-safe: single render pass, no motion
    renderHelix(ctx, { width: canvas.width, height: canvas.height, palette: active, NUM });

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Liber Arcanae Pantheon Atlas</title>
  <meta name="description" content="Offline-first pantheon atlas for Codex 144:99 with ND-safe calm mode controls.">
  <link rel="canonical" href="https://liber-arcanae.local/app/">
  <meta name="theme-color" content="#6c5ba7">
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="icon" type="image/png" sizes="192x192" href="img/icons/icon-192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="img/icons/icon-512.png">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <a class="skip-link" href="#main">Skip to content</a>
  <header class="site-header" role="banner">
    <div class="site-identity">
      <h1>Liber Arcanae Pantheon Atlas</h1>
      <p>Layered geometry and tarot research channels held within Codex 144:99 for offline study.</p>
    </div>
    <button id="calm-toggle" class="calm-toggle" type="button" aria-pressed="false" aria-describedby="calm-note">
      <span class="calm-toggle__label">Calm mode off</span>
    </button>
  </header>
  <p id="calm-note" class="visually-hidden">Calm mode softens color contrast and disables motion for ND-safe review.</p>
  <main id="main" tabindex="-1">
    <section class="hero" aria-labelledby="hero-heading">
      <div class="hero-media">
        <img src="img/black-madonna.webp" alt="Aurora gate gradient evoking Leonora Carrington constellations." loading="lazy" decoding="async" width="720" height="450">
      </div>
      <div class="hero-copy">
        <h2 id="hero-heading">Aurora Gate Research Anchor</h2>
        <p>This calm field is a grounded stand-in when Git LFS art is unavailable offline. It keeps the palette below 200 KB and honors the covenant&apos;s layered geometry request.</p>
      </div>
    </section>
    <section class="catalogue" aria-labelledby="pantheon-heading">
      <div class="catalogue-head">
        <h2 id="pantheon-heading">Pantheon Node Catalogue</h2>
        <p class="status-line" data-status role="status" aria-live="polite">Preparing node stream…</p>
      </div>
      <div id="node-list" class="node-list" role="list"></div>
    </section>
    <section class="cosmic-helix" aria-labelledby="helix-heading">
      <div class="cosmic-head">
        <h2 id="helix-heading">Cosmic Helix Renderer</h2>
        <p class="status-line" id="helix-status" role="status" aria-live="polite">Preparing helix layers…</p>
      </div>
      <canvas id="helix-stage" width="1440" height="900" aria-label="Layered sacred geometry canvas" role="img">
        Your browser does not support canvas. The helix lattice requires a modern browser.
      </canvas>
      <p class="cosmic-note">This static renderer encodes Vesica, Tree-of-Life, Fibonacci, and a static double-helix lattice. No animation, no autoplay, no external libraries. Open this file directly.</p>
    </section>
  </main>
  <footer class="site-footer">
    <p>Service worker keeps the atlas offline-first; manifest icons cover 192 and 512 requirements.</p>
  </footer>
  <script type="module">
    import { initNodeGallery } from './js/loadNodes.js';
    import { renderHelix } from './js/helix-renderer.mjs';

    const nodeStatusEl = document.querySelector('[data-status]');
    const nodeListEl = document.getElementById('node-list');
    const calmToggle = document.getElementById('calm-toggle');
    const calmLabel = calmToggle.querySelector('.calm-toggle__label');
    const helixCanvas = document.getElementById('helix-stage');
    const helixStatus = document.getElementById('helix-status');
    const helixCtx = helixCanvas ? helixCanvas.getContext('2d') : null;

    const storageKey = 'liber-arcanae.calm-mode';
    const mql = window.matchMedia('(prefers-reduced-motion: reduce)');

    const defaults = {
      palette: {
        bg: '#0b0b12',
        ink: '#e8e8f0',
        layers: ['#b1c7ff', '#89f7fe', '#a0ffa1', '#ffd27f', '#f5a3ff', '#d0d0e6']
      }
    };

    const NUM = {
      THREE: 3,
      SEVEN: 7,
      NINE: 9,
      ELEVEN: 11,
      TWENTYTWO: 22,
      THIRTYTHREE: 33,
      NINETYNINE: 99,
      ONEFORTYFOUR: 144
    };

    let paletteActive = clonePalette(defaults.palette);
    let paletteCalm = createCalmPalette(paletteActive);
    let paletteMessage = 'Preparing palette…';
    let calmActive = false;
    let manualOverride = false;

    initNodeGallery({ listEl: nodeListEl, statusEl: nodeStatusEl });

    const storedPreference = getStoredPreference();
    const startCalm = storedPreference === 'on' || (storedPreference === null && mql.matches);
    manualOverride = storedPreference !== null;
    applyCalmState(startCalm, storedPreference !== null ? 'stored' : 'preference');

    calmToggle.addEventListener('click', () => {
      const nextState = !calmActive;
      manualOverride = nextState !== mql.matches;
      applyCalmState(nextState, manualOverride ? 'manual' : 'sync');
      setStoredPreference(nextState ? 'on' : 'off');
    });

    const handleMotionChange = (event) => {
      if (manualOverride) {
        return; // Respect user override per ND-safe covenant
      }
      applyCalmState(event.matches, 'preference');
    };

    if (typeof mql.addEventListener === 'function') {
      mql.addEventListener('change', handleMotionChange);
    } else if (typeof mql.addListener === 'function') {
      mql.addListener(handleMotionChange);
    }

    if (helixCtx) {
      prepareHelixPalette();
    } else {
      helixStatus.textContent = 'Canvas context unavailable; helix lattice cannot render in this browser.';
    }

    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js').catch((error) => {
          console.warn('Service worker registration failed:', error);
        });
      });
    }

    async function prepareHelixPalette() {
      const data = await loadJSON('./data/palette.json');
      if (data) {
        paletteActive = sanitizePalette(data, defaults.palette);
        paletteMessage = 'Palette loaded.';
      } else {
        paletteActive = clonePalette(defaults.palette);
        paletteMessage = 'Palette missing; using safe fallback.';
      }
      paletteCalm = createCalmPalette(paletteActive);
      updateHelixStatus('palette');
      renderHelixLayer();
    }

    function applyCalmState(active, source) {
      calmActive = active;
      document.body.classList.toggle('calm-mode', active);
      syncCalmState(active);
      updateHelixStatus(source);
      renderHelixLayer();
    }

    function syncCalmState(active) {
      calmToggle.setAttribute('aria-pressed', active ? 'true' : 'false');
      calmLabel.textContent = active ? 'Calm mode on' : 'Calm mode off';
    }

    function renderHelixLayer() {
      if (!helixCtx) {
        return;
      }
      const palette = calmActive ? paletteCalm : paletteActive;
      // ND-safe: render once with ordered layers, no motion or flashing
      renderHelix(helixCtx, {
        width: helixCanvas.width,
        height: helixCanvas.height,
        palette,
        NUM
      });
    }

    function updateHelixStatus(source) {
      if (!helixStatus) {
        return;
      }
      if (!helixCtx) {
        helixStatus.textContent = 'Canvas context unavailable; helix lattice cannot render in this browser.';
        return;
      }
      const calmNote = calmActive ? ' Calm Mode active for softened hues.' : ' Calm Mode off for full contrast.';
      let origin = '';
      if (source === 'manual') {
        origin = ' Manual override engaged.';
      } else if (source === 'sync') {
        origin = ' Manual override cleared; synced with system preference.';
      } else if (source === 'preference') {
        origin = ' Honoring system calm preference.';
      } else if (source === 'stored') {
        origin = ' Restored from saved preference.';
      } else if (source === 'palette') {
        origin = ' Palette refreshed.';
      }
      helixStatus.textContent = paletteMessage + calmNote + origin;
    }

    function getStoredPreference() {
      try {
        return window.localStorage.getItem(storageKey);
      } catch (error) {
        console.warn('localStorage unavailable, calm mode defaults only.', error);
        return null;
      }
    }

    function setStoredPreference(value) {
      try {
        window.localStorage.setItem(storageKey, value);
      } catch (error) {
        console.warn('Unable to persist calm mode preference.', error);
      }
    }

    async function loadJSON(path) {
      try {
        const res = await fetch(path, { cache: 'no-store' });
        if (!res.ok) throw new Error(String(res.status));
        return await res.json();
      } catch (error) {
        return null; // Offline-first: fall back quietly when palette file is absent
      }
    }

    function sanitizePalette(input, fallback) {
      if (!input || typeof input !== 'object') {
        return clonePalette(fallback);
      }
      const safe = {
        bg: isHex(input.bg) ? input.bg : fallback.bg,
        ink: isHex(input.ink) ? input.ink : fallback.ink,
        layers: Array.isArray(input.layers) ? input.layers.filter(isHex) : []
      };
      const needed = fallback.layers.length;
      while (safe.layers.length < needed) {
        safe.layers.push(fallback.layers[safe.layers.length % fallback.layers.length]);
      }
      safe.layers = safe.layers.slice(0, needed);
      return safe;
    }

    function clonePalette(palette) {
      return { bg: palette.bg, ink: palette.ink, layers: palette.layers.slice() };
    }

    function createCalmPalette(base) {
      // ND-safe: soften hues without removing contrast hierarchy
      return {
        bg: mixHex(base.bg, base.ink, 0.08),
        ink: base.ink,
        layers: base.layers.map((layer) => mixHex(layer, base.ink, 0.25))
      };
    }

    function isHex(value) {
      return typeof value === 'string' && /^#[0-9a-fA-F]{6}$/.test(value);
    }

    function mixHex(hexA, hexB, weight) {
      const a = hexToRgb(hexA);
      const b = hexToRgb(hexB);
      const w = clamp(weight, 0, 1);
      const blended = {
        r: Math.round(a.r * (1 - w) + b.r * w),
        g: Math.round(a.g * (1 - w) + b.g * w),
        b: Math.round(a.b * (1 - w) + b.b * w)
      };
      return rgbToHex(blended);
    }

    function hexToRgb(hex) {
      const clean = hex.replace('#', '');
      const r = parseInt(clean.slice(0, 2), 16);
      const g = parseInt(clean.slice(2, 4), 16);
      const b = parseInt(clean.slice(4, 6), 16);
      return { r: Number.isNaN(r) ? 0 : r, g: Number.isNaN(g) ? 0 : g, b: Number.isNaN(b) ? 0 : b };
    }

    function rgbToHex({ r, g, b }) {
      return '#' + [r, g, b].map((value) => clamp(value, 0, 255).toString(16).padStart(2, '0')).join('');
    }

    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }

  </script>
</body>
</html>
