<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Cosmic Helix Renderer (ND-safe, Offline)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <meta name="color-scheme" content="light dark">
  <style>
    /* ND-safe: calm contrast, no motion, layered spacing */
    :root { --bg:#0b0b12; --ink:#e8e8f0; --muted:#a6a6c1; }
    html,body { margin:0; padding:0; background:var(--bg); color:var(--ink); font:14px/1.5 system-ui,-apple-system,"Segoe UI",Roboto,sans-serif; }
    header { padding:12px 16px; border-bottom:1px solid #1d1d2a; }
    main { padding:0 16px 24px; }
    .status { color:var(--muted); font-size:12px; }
    #stage { display:block; margin:24px auto 16px; box-shadow:0 0 0 1px #1d1d2a; background:var(--bg); }
    .note { max-width:900px; margin:0 auto; color:var(--muted); }
    strong { letter-spacing:0.01em; }
  </style>
</head>
<body>
  <header>
    <div><strong>Cosmic Helix Renderer</strong> — layered sacred geometry (offline, ND-safe)</div>
    <div class="status" id="status" role="status" aria-live="polite">Loading palette…</div>
  </header>
  <main>
    <canvas id="stage" width="1440" height="900" aria-label="Layered sacred geometry canvas" role="img"></canvas>
    <p class="note">This static renderer encodes Vesica, Tree-of-Life, Fibonacci, and a static double-helix lattice. No animation, no autoplay, no external libraries. Open this file directly.</p>
  </main>
  <script type="module">
    import { renderHelix } from "./js/helix-renderer.mjs";

    const statusEl = document.getElementById("status");
    const canvas = document.getElementById("stage");
    const ctx = canvas.getContext("2d");

    // Numerology constants anchor each layer's proportions.
    const NUM = { THREE:3, SEVEN:7, NINE:9, ELEVEN:11, TWENTYTWO:22, THIRTYTHREE:33, NINETYNINE:99, ONEFORTYFOUR:144 };

    // ND-safe defaults keep contrast gentle when palette data is missing.
    const DEFAULT_PALETTE = {
      bg:"#0b0b12",
      ink:"#e8e8f0",
      layers:["#b1c7ff","#89f7fe","#a0ffa1","#ffd27f","#f5a3ff","#d0d0e6"]
    };

    const paletteData = await loadJSON("./data/palette.json");
    const palette = sanitizePalette(paletteData, DEFAULT_PALETTE);
    statusEl.textContent = paletteData ? "Palette loaded." : "Palette missing; using safe fallback.";
    applyPaletteToDocument(palette);

    if (!ctx) {
      statusEl.textContent += " Canvas context unavailable; static illustration cannot render.";
    } else {
      renderHelix(ctx, { width:canvas.width, height:canvas.height, palette, NUM });
    }

    async function loadJSON(path) {
      try {
        const res = await fetch(path, { cache:"no-store" });
        if (!res.ok) throw new Error(String(res.status));
        return await res.json();
      } catch (err) {
        return null; // Offline-first: fall back quietly.
      }
    }

    function sanitizePalette(data, fallback) {
      if (!data || typeof data !== "object") return clonePalette(fallback);
      const sanitized = {
        bg:isHex(data.bg) ? data.bg : fallback.bg,
        ink:isHex(data.ink) ? data.ink : fallback.ink,
        layers:Array.isArray(data.layers) ? data.layers.filter(isHex) : []
      };
      const needed = 4; // four layers in the renderer
      while (sanitized.layers.length < needed) {
        sanitized.layers.push(fallback.layers[sanitized.layers.length % fallback.layers.length]);
      }
      sanitized.layers = sanitized.layers.slice(0, needed);
      return sanitized;
    }

    function clonePalette(palette) {
      return { bg:palette.bg, ink:palette.ink, layers:palette.layers.slice() };
    }

    function isHex(value) {
      return typeof value === "string" && /^#[0-9a-fA-F]{6}$/.test(value);
    }

    function applyPaletteToDocument(palette) {
      const root = document.documentElement.style;
      root.setProperty("--bg", palette.bg);
      root.setProperty("--ink", palette.ink);
      document.body.style.background = palette.bg;
      document.body.style.color = palette.ink;
    }
  </script>
</body>
</html>
